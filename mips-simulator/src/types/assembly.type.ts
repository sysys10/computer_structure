interface Token {
  type: number
  value: string | number // String for most, number for INTEGER, maybe offset too?
  offset?: number // For COMOPR
}
interface AssemblerConfig {
  dataStartAddr?: number
  textStartAddr?: number
}

type SymbolTable = { [label: string]: number }

interface StatusTable {
  currentSegment: 'text' | 'data'
  textAddr: number
  dataAddr: number
}

// Type for unresolved machine code needing label resolution
interface UnresolvedMachineCode {
  opcode: number
  rs?: number
  rt?: number
  rd?: number // For R-type placeholders if needed during expansion
  shamt?: number // For R-type shifters
  funct?: number // For R-type
  label: string
  addr: number // Address of this instruction for relative calculations
  type: 'J' | 'BRANCH' | 'LA_LUI' | 'LA_ORI' | 'OTHER_LABEL' // Type of resolution needed
}

interface ParsedLineInfo {
  addr: number
  line: number
  size: number // Size in bytes generated by this line
  machineCode: number | UnresolvedMachineCode | null // Machine code or info for pass 2
  dataValues: (number | string)[] // Raw data values (numbers or label strings)
  symbol: string | null // Label defined on this line
  isData: boolean
  directive: string | null
  instruction: string | null
  operands: any[] // Store raw operands for debugging/pass 2 info
}

interface MipsInstructionInfo {
  format: 'RRR' | 'RRI' | 'RRA' | 'RC' | 'RI' | 'R' | 'I' | 'N' // Instruction formats
  opcode: number
  funct?: number // Only for R-type
}

type RegisterMap = { [regName: string]: number }

interface AssemblyResult {
  textStart: number
  dataStart: number
  textSize: number
  dataSize: number
  textMem: number[] // Word array
  dataMem: number[] // Word array
  sourceMap: { [address: number]: number }
  symbolTable: SymbolTable
}

export type {
  Token,
  AssemblerConfig,
  SymbolTable,
  StatusTable,
  UnresolvedMachineCode,
  ParsedLineInfo,
  MipsInstructionInfo,
  RegisterMap,
  AssemblyResult,
}
